---
layout: post
title:  "Partie serveur"
date:   2018-01-21 16:16:01
categories: jekyll update
---

![image](/assets/serveur.png)

<p style="text-align:justify;">Nous avons choisi de coder notre serveur en JavaScript. Ce choix est basé sur le fait
que nous avons vu ce langage en cours et c’est donc le langage que l’on maîtrise le mieux. De
plus, dans le cours de WebObject, nous avons fait un serveur de tchat. Nous allons donc utiliser
les bases de ce serveur pour concevoir le nôtre. Cela facilitera sa conception. Nous avons
également vu que node.JS était compatible avec CoreNLP. Il existe des packages (corenlp) et
des wrapper (stanford-corenlp) disponibles. Ainsi, notre partie traitement de langage va
pouvoir communiquer sans problème avec le serveur. De plus, vous verrez ensuite que le
serveur traite également avec le client. Il existe des librairies compatibles avec Android, cela
va donc faciliter la mise en place de la communication.</p>


<p style="text-align:justify;">Dans le serveur, il y aura deux parties, une partie traitement des commandes et une
partie base de données. Comme vous l’avez vu, le client va devoir s’authentifier avec un nom
d’utilisateur et un mot de passe. Il va falloir stocker ces données. Pour cela, les bases de
données relationnelles sont les plus adaptés à notre projet. En effet, pour notre projet, nous
aurons juste besoin de stocker le pseudo et le mot de passe de l’utilisateur, donc notre schéma
n’aura pas besoin d’être modifié.
Nous allons devoir également stocker les informations concernant les commandes clients et
les objets connectés. Nous devrons également stocker les différents scénarios déclenchables
par l’utilisateur. Au final les schémas resteront les mêmes et donc la base de données
relationnelle est tout à fait adaptée.
Nous avons choisi d’utiliser sqlite3 car nous l’avons déjà utilisé l’année dernière et donc nous
avons des connaissances sur cette base.
Notre serveur servira de broker pour les équipements communiquant en MQTT (voir partie
V.B-module).</p>

Notre serveur aura trois rôles dans l’envoi de données :
- Envoyer des données au client
- Envoyer des données aux objets connectés
- Transmettre les commandes clients à la partie traitement du langage

# 1. Envoyer des données au client

<p style="text-align:justify;">Il y aura deux moments où le serveur enverra des données au client. Le premier est
lorsque que le client s'authentifie. Ainsi, lorsqu’il aura reçu les données du client, le serveur
stockera ces données dans une base de données puis renverra au client la validité ou non de
son authentification.
Dans un second temps, lorsque le client enverra des commandes via l’application
mobile afin d’effectuer des actions sur les objets connectés, le serveur renverra l’état de la
commande si un retour d’état est disponible avec l’objet en question. C’est-à-dire que le client
aura la possibilité de savoir si sa commande a bien été effectuée ou non. On utilise le protocole
de communication TCP/ IP.
Ces différents retours d’état seront envoyés sous le format JSON.</p>

<p style="text-align:justify;">Le format JSON d’un message envoyé au client lors d’une authentification sera le suivant :</p>
<div style="text-align:center;">{nom : « nomClient », action : « authentification », réponse : « acceptée ou non »}</div>

# 2. Envoyer des données aux objets connectés

<p style="text-align:justify;">Pour les objets connectés, il y aura deux cas de figures. C’est-à-dire qu’il peut y avoir
des objets connectés, tels que la lampe ikea tradfri, qui possèdent une box ou un module
préinstallé permettant de faire office de relai entre le protocole WIFI et le protocole compris
par l’objet connecté. Il y a également d’autres objets qui n’ont pas ce genre de modules. Ainsi
le serveur devra être capable de s’adapter. Lorsqu’une box sera présente, le serveur se servira
des librairies préalablement installées permettant de communiquer avec la box (ex : libcoap,
voir en annexe). Ensuite la box se chargera de communiquer avec l’équipement.
S’il n’y a pas de box, il faudra alors installer un module hardware faisant office de relai
permettant au serveur de communiquer avec les différents équipements.</p>

# 3. Recevoir des données du client

<p style="text-align:justify;">Lorsque le client veut envoyer une commande elle passe d’abord par notre partie
serveur avant d’être transférée à la partie traitement du langage. Le serveur recevra donc les
commandes client en brut. </p>

# 4. Recevoir/Envoyer les données de la partie traitement du langage

<p style="text-align:justify;">Une fois que les données seront traitées, les messages seront renvoyés par la partie
traitement langage vers la partie serveur. Le serveur ira comparer les données reçues à celles
de sa base de données afin d’envoyer les commandes aux objets connectés adéquats.
Les messages seront également transférés à la partie traitement du langage en brut.</p>

# 5. Test du serveur

<p style="text-align:justify;">Afin de pouvoir tester le bon fonctionnement de notre serveur nous utiliserons un
programme Javascript exécutable avec node.js. Elle pourra communiquer avec la partie
serveur afin d’effectuer des commandes clients et pour l’authentification. Cette partie sera
donc la partie client de notre solution. Les messages se transmettront au travers de sockets
TCP et seront au format JSON. Les fonctions implémentées seront les suivantes :</p>
1. Le client test doit pouvoir demander la liste des objets connectés et leur état
s’ils peuvent le fournir.
2. Il est possible de modifier l’état d’un objet (allumer ou éteindre une lampe,
etc.). Il n’est possible de modifier que l’état d’un équipement à la fois. La
possibilité de créer des scènes ne sera implémentée que plus tard.
3. Le client doit pouvoir quitter l’application proprement.
4. Le client doit pouvoir parler en langage naturel. Il doit être restreint le moins
possible sur le format des demandes.
<p style="text-align:justify;">Le format JSON d’un message envoyé à la partie traitement du langage lors d’une commande
client sera le suivant :</p>

<div style="text-align:center;">nom : « nomClient », action : « commande du client », objet : « nomObjet »}</div>

<p style="text-align:justify;">La commande du client transmise sera non modifiée. C’est la partie traitement du langage qui
s’en chargera.</p>

<p style="text-align:justify;">Le format JSON d’un message dans le cadre de l’authentification sera le suivant :</p>

<div style="text-align:center;">{action : « connection », pseudo : « pseudoINPUT », mdp : « mdpINPUT »}</div>

<p style="text-align:justify;">Toutes les données échangées seront cryptées, selon le modèle exposé dans la partie sécurité.</p>
